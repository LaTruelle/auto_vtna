# -*- coding: utf-8 -*-
"""Copie de Bienvenue dans Colaboratory

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1grF35eFF8sJkURu2b39XbM7EpvXGVJVD

# Curve Area Computation

## Step 1: Libraries
"""

import pandas as pd
from google.colab import files

import gspread
from oauth2client.client import GoogleCredentials

from matplotlib import pyplot as plt

import io
from google.colab import files

from statistics import mean, stdev

"""## Step 2: Uploading the local spreadsheet


"""

uploaded = files.upload()

for fn in uploaded.keys():
  print('User uploaded file "{name}" with length {length} bytes'.format(
      name=fn, length=len(uploaded[fn])))

df = pd.read_csv(io.BytesIO(uploaded['cat.csv']), error_bad_lines=False, delimiter = ";", decimal=',')

#pre processing
df.Csol = df.Csol.astype(float)
df.Ccat = df.Ccat.astype(float)
df.Cmol = df.Cmol.astype(int)
df.dropna(inplace = True)
df

mol = set(df.Cmol)
print(mol)

plt.style.use('seaborn-darkgrid')

palette = plt.get_cmap('Set1')
num = 0
for i in mol:
  num += 1
  x = list(df.Ccat[df.Cmol==i].array)
  y = list(df.Csol[df.Cmol==i].array)
  plt.plot(x, y, marker='', color=palette(num), linewidth=2, alpha=0.9, label="test" + str(i))
plt.show()

"""## Fonctions

"""

def afine_area(x_coordinates, y_coordinates, debug = False):
  #setting initial area to 0
  area = 0
  for i in range(1, len(x)):

    #delta x
    delta_x = x_coordinates[i] - x_coordinates[i - 1]
    if debug:
      print("delta_x = {}".format(delta_x))

    #delta y
    delta_y = y_coordinates[i] - y_coordinates[i - 1]
    if debug:
      print("delta_y = {}".format(delta_y))

    #area under curve
    area = area + delta_x * y_coordinates[i - 1] + (delta_y + delta_x)/2
    if debug:
      print("area =  {}".format(area))
      print("--------------------------------------")

  if debug:
    print("total area under the curve = {}".format(area))
  return (area)

"""## Version manuelle

"""

power = 0.1499999999999997
gradient_descent = []
area_list = []
results = {}

for concentration in mol:
  print("mol = {}".format(concentration))
  #definition of x coordinates
  x = list(df.Ccat[df.Cmol==concentration].array)
  x = [i**power for i in x]
  print("x coordinates = {}".format(x))
  #definition of y coordinates
  y = list(df.Csol[df.Cmol==concentration].array)
  # y = [i**power for i in y]
  print("y coordinates = {}".format(y))

  #plotting the points
  area = 0
  plt.plot(x, y, 'bo')
  plt.show()
  area_list.append(afine_area(x, y))
  print("\n")

print("area_list = {}".format(area_list))
print("mean = {}".format(mean(area_list)))
print("stdev = {}".format(stdev(area_list)))

results.update(
    {power:[mean(area_list), stdev(area_list)]}
)
gradient_descent.append(stdev(area_list))

"""# Version automatique = Finder

"""

power = 0.16
results = {}
step = 0.001
area_list = []
gradient_descent = []
power_limit = 0.1

#initialisation
for concentration in mol:
  #definition of x coordinates
  x = list(df.Ccat[df.Cmol==concentration].array)
  x = [i**power for i in x]
  print("x coordinates = {}".format(x))
  #definition of y coordinates
  y = list(df.Csol[df.Cmol==concentration].array)
  # y = [i**power for i in y]
  print("y coordinates = {}".format(y))

  #plotting the points
  area = 0
  plt.plot(x, y, 'bo')
  plt.show()
  area_list.append(afine_area(x, y))
  print("\n")

print(area_list)
print(mean(area_list))
print(stdev(area_list))

results.update(
    {power:[mean(area_list), stdev(area_list)]}
)
gradient_descent.append(stdev(area_list))



#runing the loop
iteration = 0
while True:
  area_list = []
  #starting the loop with power = power - step
  power = power - step

  for concentration in mol:
    #definition of x coordinates
    x = list(df.Ccat[df.Cmol==concentration].array)
    x = [i**power for i in x]
    print("x coordinates = {}".format(x))
    #definition of y coordinates
    y = list(df.Csol[df.Cmol==concentration].array)
    # y = [i**power for i in y]
    print("y coordinates = {}".format(y))

    #plotting the points
    area = 0
    plt.plot(x, y, 'bo')
    plt.show()
    area_list.append(afine_area(x, y))
    print("\n")

  print("area list = {}".format(area_list))
  print("mean = {}".format(mean(area_list)))
  print("st_dev = {}".format(stdev(area_list)))
  results.update(
      {power:[mean(area_list), stdev(area_list)]}
  )
  gradient_descent.append(stdev(area_list))
  print("gradient_descent")
  print(gradient_descent)

  if gradient_descent[-1] > gradient_descent[-2]:
    break
  if power <= power_limit:
    break


print(results)

### TEST
# power = 0.5
# results = {}
# step = 0.01
# area_list = []
# gradient_descent = []
# iteration_limit = 20

# #initialisation
# for concentration in mol:
#   #definition of x coordinates
#   x = list(df.Ccat[df.Cmol==concentration].array)
#   x = [i**power for i in x]
#   print("x coordinates = {}".format(x))
#   #definition of y coordinates
#   y = list(df.Csol[df.Cmol==concentration].array)
#   # y = [i**power for i in y]
#   print("y coordinates = {}".format(y))

#   #plotting the points
#   area = 0
#   plt.plot(x, y, 'bo')
#   plt.show()
#   area_list.append(afine_area(x, y))
#   print("\n")

# print(area_list)
# print(mean(area_list))
# print(stdev(area_list))

# results.update(
#     {power:[mean(area_list), stdev(area_list)]}
# )
# gradient_descent.append(stdev(area_list))



# #runing the loop
# iteration = 0
# while True:
#   area_list = []
#   #starting the loop with power = power - step
#   power = power - step

#   for concentration in mol:
#     #definition of x coordinates
#     x = list(df.Ccat[df.Cmol==concentration].array)
#     x = [i**power for i in x]
#     print("x coordinates = {}".format(x))
#     #definition of y coordinates
#     y = list(df.Csol[df.Cmol==concentration].array)
#     # y = [i**power for i in y]
#     print("y coordinates = {}".format(y))

#     #plotting the points
#     area = 0
#     plt.plot(x, y, 'bo')
#     plt.show()
#     area_list.append(afine_area(x, y))
#     print("\n")

#   print("area list = {}".format(area_list))
#   print("mean = {}".format(mean(area_list)))
#   print("st_dev = {}".format(stdev(area_list)))
#   results.update(
#       {power:[mean(area_list), stdev(area_list)]}
#   )
#   gradient_descent.append(stdev(area_list))
#   print("gradient_descent")
#   print(gradient_descent)

#   if gradient_descent[-1] > gradient_descent[-2]:
#     break
#   if iteration >= iteration_limit:
#     break
#   iteration += 1

# print(results)

#computation of area under the curve
xs = [2, 5, 4]
x_sort = sorted(xs)
ys = [6, 7, 8]
sum = 0
plt.plot(xs, ys, 'bo')
plt.show()
for i in range(1, len(xs)):
    slope = (xs[i]-xs[i-1])/(ys[i] - ys[i-1])
    delta_x = x_sort[i] - x_sort[i - 1]
    delta_y =  ys[i - 1] + (ys[i-1] + delta_x * slope)
    sum = sum + (delta_y/2 * delta_x)
print(sum)

#etape 1 ajouter toutes les valeurs de tCAL exposant Ã  a table
#converger vers un expostant tcal avec ecart d'aire minimal